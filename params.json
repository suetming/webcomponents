{"name":"Web组件","tagline":"Web Components","body":"Web组件\r\n=======\r\n译者：suetming\r\n\r\n原文：[Web Components](http://www.w3.org/TR/2013/WD-components-intro-20130606/)\r\n\r\n1 关于本文\r\n-----------\r\n\r\n注意文章涉及正在开展的工作. 关系到web组件的一系列概念，每个概念都有各自的规范.\r\n这是一个迭代的过程\r\n\r\n本文描述的概念有时会落后或者超前于专门界定此概念的规范，一旦本文涉及的前瞻性技术被相应的规范所采纳，本文会更新并注明\r\n\r\n2 介绍\r\n------------\r\nweb组件模型由5部分组成：\r\n\r\n- 1. Templates：由一系列复用时能被激活的标记组成\r\n- 2. Decorators：用于Templates中，通过CSS丰富和控制交互改变文本\r\n- 3. Custom Elements：让用户可以自定义元素[自定义元素名、自定义API接口\r\n- 4. Shadow DOM：将一组DOM树封装成一个用户接口元素\r\n- 5. Imports：定义如何将Templates、Decorators和Custom Elements打包，并且能够以资源的形式从外部引用\r\n\r\n每一部分都有各自的用途. 如果将这5种技术引入，开发人员可以轻松的编写拥有复杂交互体验的组件，并且可以轻松引用和组装，这是今天的CSS和脚本语言所无法达到的\r\n\r\n本文将会讨论这5种技术，并举例说明其在Web组件中的作用\r\n\r\n3 Templates\r\n--------------\r\n具体规范参加这篇[HTML Templates](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html)\r\n\r\n\\<template\\>元素及其所包含元素会由解析器进行解析并标记，不过不会立即渲染出来，脚本不会立即执行，包含的图片也不会立即下载\r\n\r\n\\<template\\>元素有一个属性 __content__ 存储元素的实际内容，属性 __content__ 的内容可以拷贝移动到HTML节点中\r\n\r\n```html\r\n<template id=\"commentTemplate\">\r\n    <div>\r\n        <img src=\"\">\r\n        <div class=\"comment-text\"></div>\r\n    </div>\r\n</template>\r\n<script>\r\nfunction addComment(imageUrl, text) {\r\n  var t = document.querySelector(\"#commentTemplate\");\r\n  var comment = t.content.cloneNode(true);\r\n  // Populate content.\r\n  comment.querySelector('img').src = imageUrl;\r\n  comment.querySelector('.comment-text').textContent = text;\r\n  document.body.appendChild(comment);\r\n}\r\n</script>\r\n```\r\n\r\n__template__ 所包含的的元素包含在属性 __content__ 中，通过script拷贝里面的元素并插入到HTML中使图片加载进来，脚本开始运行. 例如，在templates引入大型脚本，需要时调用\r\n\r\n4 Decorators\r\n--------------\r\nDecorators 目前没有标准文档，__decorator__ 主要加强或者重载已经存在的元素，由CSS控制表现，与一般元素不同的是通过标记可以达到额外的效果\r\n\r\n\\<decorator\\>通过包含\\<template\\>来明确具体渲染哪一块\r\n\r\n```html\r\n<decorator id=\"details-open\">\r\n    <template>\r\n        <a id=\"summary\">\r\n          &blacktriangledown;\r\n          <content select=\"summary\"></content>\r\n        </a>\r\n        <content></content>\r\n    </template>\r\n</decorator>\r\n```\r\n\r\n\\<content\\>包含待渲染的内容，通过CSS控制生效\r\n\r\n```css\r\ndetails[open] {\r\n    decorator: url(#details-open);\r\n}\r\n```\r\n\r\n通过这种方式可以使下面的html代码\r\n\r\n```html\r\n<details open>\r\n    <summary>Timepieces</summary>\r\n    <ul>\r\n      <li>Sundial\r\n      <li>Cuckoo clock\r\n      <li>Wristwatch\r\n    </ul>\r\n</details>\r\n```\r\n\r\n最终渲染成\r\n\r\n<a>\r\n  ▾ Timepieces\r\n</a>\r\n<ul>\r\n  <li>Sundial\r\n  </li><li>Cuckoo clock\r\n  </li><li>Wristwatch\r\n</li></ul>\r\n\r\n__decorator__ CSS属性可以指向任何网络资源，不过只有其“定义”被调用才能申请，生成的标记仅限于展示，永远不会运行脚本包括内联事件，而且也是不可编辑的","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}