{"name":"Web组件","tagline":"Web Components","body":"Web组件\r\n=======\r\n译者：suetming\r\n\r\n原文：[Web Components](http://www.w3.org/TR/2013/WD-components-intro-20130606/)\r\n\r\n1 关于本文\r\n-----------\r\n\r\n注意文章涉及正在开展的工作. 关系到web组件的一系列概念，每个概念都有各自的规范.\r\n这是一个迭代的过程\r\n\r\n本文描述的概念有时会落后或者超前于专门界定此概念的规范，一旦本文涉及的前瞻性技术被相应的规范所采纳，本文会更新并注明\r\n\r\n2 介绍\r\n------------\r\nweb组件模型由5部分组成：\r\n\r\n- 1. Templates：由一系列复用时能被激活的标记组成\r\n- 2. Decorators：用于Templates中，通过CSS丰富和控制交互改变文本\r\n- 3. Custom Elements：让用户可以自定义元素[自定义元素名、自定义API接口\r\n- 4. Shadow DOM：将一组DOM树封装成一个用户接口元素\r\n- 5. Imports：定义如何将Templates、Decorators和Custom Elements打包，并且能够以资源的形式从外部引用\r\n\r\n每一部分都有各自的用途. 如果将这5种技术引入，开发人员可以轻松的编写拥有复杂交互体验的组件，并且可以轻松引用和组装，这是今天的CSS和脚本语言所无法达到的\r\n\r\n本文将会讨论这5种技术，并举例说明其在Web组件中的作用\r\n\r\n3 Templates\r\n--------------\r\n具体规范参加这篇[HTML Templates](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html)\r\n\r\n\\<template\\>元素及其所包含元素会由解析器进行解析并标记，不过不会立即渲染出来，脚本不会立即执行，包含的图片也不会立即下载\r\n\r\n\\<template\\>元素有一个属性 __content__ 存储元素的实际内容，属性 __content__ 的内容可以拷贝移动到HTML节点中\r\n\r\n```html\r\n<template id=\"commentTemplate\">\r\n    <div>\r\n        <img src=\"\">\r\n        <div class=\"comment-text\"></div>\r\n    </div>\r\n</template>\r\n<script>\r\nfunction addComment(imageUrl, text) {\r\n  var t = document.querySelector(\"#commentTemplate\");\r\n  var comment = t.content.cloneNode(true);\r\n  // Populate content.\r\n  comment.querySelector('img').src = imageUrl;\r\n  comment.querySelector('.comment-text').textContent = text;\r\n  document.body.appendChild(comment);\r\n}\r\n</script>\r\n```\r\n\r\n__template__ 所包含的的元素包含在属性 __content__ 中，通过script拷贝里面的元素并插入到HTML中使图片加载进来，脚本开始运行. 例如，在templates引入大型脚本，需要时调用\r\n\r\n4 Decorators\r\n--------------\r\nDecorators 目前没有标准文档，__decorator__ 主要加强或者重载已经存在的元素，由CSS控制表现，与一般元素不同的是通过标记可以达到额外的效果\r\n\r\n\\<decorator\\>通过包含\\<template\\>来明确具体渲染哪一块\r\n\r\n```html\r\n<decorator id=\"details-open\">\r\n    <template>\r\n        <a id=\"summary\">\r\n          &blacktriangledown;\r\n          <content select=\"summary\"></content>\r\n        </a>\r\n        <content></content>\r\n    </template>\r\n</decorator>\r\n```\r\n\r\n\\<content\\>包含待渲染的内容，通过CSS控制生效\r\n\r\n```css\r\ndetails[open] {\r\n    decorator: url(#details-open);\r\n}\r\n```\r\n\r\n通过这种方式可以使下面的html代码\r\n\r\n```html\r\n<details open>\r\n    <summary>Timepieces</summary>\r\n    <ul>\r\n      <li>Sundial\r\n      <li>Cuckoo clock\r\n      <li>Wristwatch\r\n    </ul>\r\n</details>\r\n```\r\n\r\n最终渲染成\r\n\r\n<a>\r\n  ▾ Timepieces\r\n</a>\r\n<ul>\r\n  <li>Sundial\r\n  </li><li>Cuckoo clock\r\n  </li><li>Wristwatch\r\n</li></ul>\r\n\r\n__decorator__ CSS属性可以指向任何网络资源，不过只有其“定义”被调用才能申请，生成的标记仅限于展示，永远不会运行脚本包括内联事件，而且也是不可编辑的\r\n\r\n4.1 Decorators的事件\r\nDecorators可以关联事件增强交互，decorator采用事件控制器当做媒介，因为decorator可能在任何时间生效或者失效，所以关联template中监听节点事件或者获取其状态都是无效的\r\n\r\n![事件注册](http://www.w3.org/TR/2013/WD-components-intro-20130606/event-handler-registration.png)\r\n\r\n通过事件控制器注册事件监听器，template中插入\\<script\\>，decorator元素插入到文档中时脚本会执行，脚本会被插入到注册队列中:\r\n\r\n```html\r\n<decorator id=\"details-open\">\r\n    <script>\r\n        function clicked(event) {\r\n            event.target.removeAttribute('open');\r\n        }\r\n        [{selector: '#summary', type: 'click', handler: clicked}];\r\n    </script>\r\n    <template>\r\n      <a id=\"summary\">\r\n        <!-- as illustrated above -->\r\n```\r\n\r\n事件控制器解析注册事件如图所示\r\n\r\n![事件的路由和重定向](http://www.w3.org/TR/2013/WD-components-intro-20130606/event-routing-retargeting.png)\r\n\r\n事件监听器被调用时，事件的目标是最终生成的内容而不是template中的内容. 点击template中定义的▾，将会调用单击事件（在template中定义的__\\#summary__元素）, event.target指向\\<details\\>，事件的重定向不会影响文档DOM结构\r\n\r\n移除属性__open__，由于selector与decorator的属性不匹配，这个decorator不再有效. 未应用的decorator会回到最初的状态. 不过可以再构造一个decorator来渲染__closed__，通过激活不同的decorator可以达到无状态交互，代码如下\r\n\r\n```html\r\n<style>\r\ndetails {\r\n    decorator: url(#details-closed);\r\n}\r\ndetails[open] {\r\n    decorator: url(#details-open);\r\n}\r\n</style>\r\n\r\n<decorator id=\"details-closed\">\r\n    <script>\r\n        function clicked(event) {\r\n            event.target.setAttribute('open', 'open');\r\n        }\r\n        [{selector: '#summary', type: 'click', handler: clicked}];\r\n    </script>\r\n    <template>\r\n        <a id=\"summary\">\r\n            &blacktriangleright; <content select=\"summary\"></content>\r\n        </a>\r\n    </template>\r\n</decorator>\r\n\r\n<decorator id=\"details-open\">\r\n    <!-- as illustrated above -->\r\n```\r\n\r\n5 Custom Elements\r\n----------------------------\r\n\r\n技术规范见此[The Custom Elements specification](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html)\r\n\r\n用户可以构造新的DOM元素，这种技术称之为Custom Elements. 不像decorators，自定义元素可以封装状态并提供脚本接口. 下面的数据表表明两者区别\r\n\r\n<table>\r\n   <tr>\r\n      <td></td>\r\n      <td>Decorators</td>\r\n      <td>Custom Elements</td>\r\n   </tr>\r\n   <tr>\r\n      <td>Lifetime</td>\r\n      <td>Ephemeral, while a CSS selector matches</td>\r\n      <td>Stable, matches entire element lifetime</td>\r\n   </tr>\r\n   <tr>\r\n      <td>Applied, unapplied dynamically</td>\r\n      <td>Yes, based on CSS selectors</td>\r\n      <td>No, fixed at element creation time</td>\r\n   </tr>\r\n   <tr>\r\n      <td>Accessible through script</td>\r\n      <td>No, transparent to DOM; cannot add interfaces</td>\r\n      <td>Yes, accessible through DOM; can provide interfaces</td>\r\n   </tr>\r\n   <tr>\r\n      <td>State</td>\r\n      <td>Stateless projection</td>\r\n      <td>Stateful DOM object</td>\r\n   </tr>\r\n   <tr>\r\n      <td>Behavior</td>\r\n      <td>Simulated by changing decorators</td>\r\n      <td>First-class using script and events</td>\r\n   </tr>\r\n</table>\r\n\r\n5.1 构造一个自定义元素\r\n-------------------------------------------\r\n用\\<element\\>构造一个元素，并指明继承哪一个属性如下：\r\n\r\n```html\r\n<element extends=\"button\" name=\"fancy-button\">\r\n    …\r\n</element>\r\n```\r\n\r\n__extends__属性标记继承于哪一个元素，自定义元素实例会有此标记名\r\n\r\n__name__属性指明元素名称，命名必须包含“-”\r\n\r\n用户的自定义元素应该继承最接近自己想法的实际存在的元素. 如果用户构造不继承任何元素的自定义元素，user agent会抛出异常[HTMLUnknownElement](http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#htmlunknownelement)\r\n\r\n5.2 方法和属性\r\n---------------\r\n将\\<script\\>插入到自定义元素中可以对自定义元素增加方法和属性，下面的例子中元素\\<tick-tock-clock\\>增加了tick方法\r\n\r\n```html\r\n<element name=\"tick-tock-clock\">\r\n  <script>\r\n    ({\r\n      tick: function () {\r\n        …\r\n      }\r\n    });\r\n  </script>\r\n</element>\r\n```\r\n\r\n5.3 生命周期回调函数\r\n自定义元素有很多回调函数如下：\r\n\r\n- readyCallback：创建时调用\r\n- insertedCallback：插入文档时调用\r\n- removedCallbakc：删除元素时调用\r\n\r\n下面的例子演示如何用template，Shadow DOM (见下一章节)，以及Custom Elements回调函数创建元素：\r\n\r\n```html\r\n<element name=\"tick-tock-clock\">\r\n  <template>\r\n    <span id=\"hh\"></span>\r\n    <span id=\"sep\">:</span>\r\n    <span id=\"mm\"></span>\r\n  </template>\r\n  <script>\r\n    var template = document.currentScript.parentNode.querySelector('template');\r\n\r\n    function start() {\r\n      this.tick();\r\n      this._interval = window.setInterval(this.tick.bind(this), 1000);\r\n    }\r\n    function stop() {\r\n      window.clearInterval(this._interval);\r\n    }\r\n    function fmt(n) {\r\n      return (n < 10 ? '0' : '') + n;\r\n    }\r\n\r\n    ({\r\n      readyCallback: function () {\r\n        this._root = this.createShadowRoot();\r\n        this._root.appendChild(template.content.cloneNode());\r\n        if (this.parentElement) {\r\n          start.call(this);\r\n        }\r\n      },\r\n      insertedCallback: start,\r\n      removedCallback: stop,\r\n      tick: function () {\r\n        var now = new Date();\r\n        this._root.querySelector('hh').textContent = fmt(now.getHours());\r\n        this._root.querySelector('sep').style.visibility =\r\n            now.getSeconds() % 2 ? 'visible' : 'hidden';\r\n        this._root.querySelector('mm').textContent = fmt(now.getMinutes());\r\n      },\r\n      chime: function () { … }\r\n    });\r\n  </script>\r\n</element>\r\n```\r\n\r\n5.4 Custom Elements实例化\r\n自定义元素均继承HTML的标准元素(div/button/option/...)， 当用户想用这些元素的时候需要用到属性__is__，如下：\r\n\r\n```html\r\n<element extends=\"button\" name=\"fancy-button\">  <!-- definition -->\r\n    …\r\n</element>\r\n\r\n<button is=\"fancy-button\">  <!-- use -->\r\n    Do something fancy\r\n</button>\r\n```\r\n\r\n5.5 Script实例化Custom Elements\r\n通过脚本语言也可以实例化自定义元素，方法为__register__，具体见下述代码：\r\n\r\n```javascript\r\nvar p = Object.create(HTMLButtonElement.prototype, {});\r\np.dazzle = function () { … };\r\n\r\n// 返回实例化对象\r\nvar FancyButton = document.register('button', 'fancy-button', {prototype: p});\r\nvar b = new FancyButton();\r\ndocument.body.appendChild(b);\r\nb.addEventListener('click', function (event) {\r\n    event.target.dazzle();\r\n});\r\n```\r\n\r\n也可以直接通过createElement生成：\r\n\r\n```javascript\r\nvar b = document.createElement('button', 'fancy-button');\r\nalert(b.outerHTML); // will display '<button is=\"fancy-button\"></button>'\r\nvar c = document.createElement('tick-tock-clock');\r\nalert(c.outerHTML); // will display '<tick-tock-clock></tick-tock-clock>'\r\n```\r\n\r\n5.6 元素更新\r\n---------------\r\n当元素定义调用的时候，每一个匹配的元素都会进行更新. 更新元素后，元素相应API会生效，生命周期相关函数会被调用.\r\n通过CSS__:unresolved__可以匹配所有为构造的自定义元素，通过这种方式避免更新元素所造成的闪烁\r\n\r\n```html\r\n<style>\r\ntick-tock-clock:unresolved {\r\n  content: '??:??';  \r\n}\r\n</style>\r\n<tick-tock-clock></tick-tock-clock> <!-- will show ??:?? -->\r\n```\r\n\r\n也可以通过脚本进行控制\r\n\r\n```javascript\r\n// Chime ALL the clocks!\r\nArray.prototype.forEach.call(\r\n  document.querySelectorAll('tick-tock-clock:not(:unresolved)'),\r\n  function (clock) { clock.chime(); });\r\n```\r\n通过自定义事件元素可以通知页面其他部分元素已经更新，可以等到元素更新完成，脚本在对其进行操作\r\n\r\n5.7 扩展Custom Elements\r\n元素也可以继承自定义元素，代码如下：\r\n```html\r\n<element extends=\"tick-tock-clock\" name=\"grand-father-clock\">\r\n    …\r\n</element>\r\n<script>\r\nvar p = Object.create(Object.getPrototypeOf(document.createElement('tick-tock-clock')));\r\np.popOutBirdie = function () { … }\r\nvar CuckooClock = document.register('cuckoo-clock', {prototype: p});\r\nvar c = new CuckooClock();\r\nc.tick();         // inherited from tick-tock-clock\r\nc.popOutBirdie(); // specific to cuckoo-clock\r\n</script>\r\n```\r\n\r\n6 Shadow DOM\r\n------------------------\r\n相应规范见这里[The Shadow DOM specification](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html)\r\n\r\nShadow DOM 是一种DOM节点的辅助树. Shadow DOM 子树能够关联某个元素，但不会显示在元素子节点中，子树有自己的作用域. 例如，一个shadow DOM 子树可以和文档中相同ID和风格的元素而不冲突，因为shadow DOM 子树与文档是完全分离的\r\n\r\nShadow DOM 通过[__createShadowRoot__](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#api-partial-element-create-shadow-root)方法生效，返回shadow DOM的根节点并填充到DOM节点中\r\n\r\n<object data=\"http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-trees.svg\" width=\"800\" height=\"430\"></object>\r\n\r\n关联shadow DOM的元素称为[shadow host](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#dfn-shadow-host). 当元素存在shadow DOM，元素的子节点不会渲染；渲染的是shadow DOM的内容\r\n\r\n<object data=\"http://www.w3.org/TR/2013/WD-components-intro-20130606/shadow-rendering.svg\" width=\"450\" height=\"400\"></object>\r\n\r\n6.1 插入点\r\nshadow DOM 子树通过\\<content\\>元素作为渲染输出插入点. \\<content\\>只是作为渲染输出的插入点，如下：\r\n\r\n```html\r\n<!-- document -->\r\n<div id=\"news\">\r\n  <h1>Good day for kittens</h1>\r\n  <div class=\"breaking\">Kitten rescued from tree</div>\r\n  <div>Area kitten \"adorable\"&mdash;owner</div>\r\n  <div class=\"breaking\">Jiggled piece of yarn derails kitten kongress</div>\r\n</div>\r\n\r\n<!-- #news' shadow -->\r\n<template id=\"t\">\r\n  <content select=\"h1\"></content>\r\n  <div id=\"ticker\">\r\n    <content id=\"stories\"></content>\r\n  </div>\r\n</template>\r\n\r\n<!-- #ticker's shadow -->\r\n<template id=\"u\">\r\n  <content class=\"highlight\" select=\".breaking\"></content>\r\n  <content></content>\r\n</template>\r\n\r\n<script>\r\n// Set up shadow DOM\r\nvar news = document.querySelector('#news');\r\nvar r = news.createShadowRoot();\r\nvar t = document.querySelector('#t');\r\nr.appendChild(t.content.cloneNode(true));\r\n\r\nvar ticker = r.querySelector('#ticker');\r\nvar s = ticker.createShadowRoot();\r\nvar u = document.querySelector('#u');\r\ns.appendChild(u.content.cloneNode(true));\r\n</script>\r\n```\r\n理论上，第一部分文档和第一部分shadow根节点生成了下面的DOM树. 宿主元素的子节点显示在插入点的位置. \r\n\r\n```\r\n<div id=\"news\">\r\n  <h1>Good day for kittens</h1>\r\n  <div id=\"ticker\">\r\n    <div class=\"breaking\">Kitten rescued from tree</div>\r\n    <div>Area kitten \"adorable\"&mdash;owner</div>\r\n    <div class=\"breaking\">Jiggled piece of yarn derails kitten kongress</div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n第二部分，由于\\<content class=\"highlight\" select=\".breaking\"\\>所有类属性为breaking的排在顶部，这种方式称为[reprojection](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#reprojection)\r\n\r\n```html\r\n<div id=\"news\">\r\n  <h1>Good day for kittens</h1>\r\n  <div id=\"ticker\">\r\n    <div class=\"breaking\">Kitten rescued from tree</div>\r\n    <div class=\"breaking\">Jiggled piece of yarn derails kitten kongress</div>\r\n    <div>Area kitten \"adorable\"&mdash;owner</div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n6.3 备用内容\r\n插入点可以有_content_，称为[备用内容](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#dfn-fallback-content)，当插入点没有任何文本时，会显示此信息，如下：\r\n\r\n```html\r\n<!-- #news' shadow -->\r\n<template id=\"t\">\r\n  <content select=\"h1\">Today's top headlines</content>\r\n  <div id=\"ticker\">\r\n    <content id=\"stories\">\r\n      No news\r\n      <button onclick=\"window.location.reload(true);\">Reload</button>\r\n    </content>\r\n  </div>\r\n</template>\r\n```\r\n\r\n6.4 多重Shadow子树\r\n---------------------------\r\n一个元素可以含有不止一个shadow DOM 子树. 继承一个已具有shadow DOM子树的自定义元素是很常见的. 不过要是想重用原先的元素时怎么处理? 如何重用?\r\n利用\\<shadow\\>可以调用原先申请的shadow DOM 子树，如下：\r\n\r\n```html\r\n<element name=\"sailing-watch\" extends=\"tick-tock-clock\">\r\n  <template>\r\n    <shadow></shadow>\r\n    <div id=\"compass\">N</div>\r\n  </template>\r\n  <script>\r\n    …\r\n  </script>\r\n</element>\r\n```\r\n\r\n由于一个元素可以有多个shadow，我们需要了解这些shadow如何相互影响，如何作用元素的子节点\r\n\r\n由于你不能删除shadow root，所以shadow DOM子树生效时的顺序很重要，如下：\r\n\r\n- 1. user agent shadow DOM\r\n- 2. 自定义元素的shadow DOM\r\n- 3. 第一个派生自定义元素的shadow DOM\r\n- 4. ...\r\n- 5. 用脚本添加的Ad-hoc shadow DOM\r\n- 6. Decorator shadow (applied and removed with CSS rules—not technically shadow DOM, but its insertion points work similarly to shadow DOM.)\r\n\r\n其次，根据顺序从最新生效的子树反向推倒，每一个\\<content\\>插入点，根据规则，可以定位任何宿主元素子节点\r\n\r\n一旦子节点在正确的地方渲染，我们可以检查是否有\\<shadow\\>元素，如果没有，表明成功；如果有，从\\<shadow\\>队列元素中取出子树重复替换\\<content\\>插入点，直到队尾. 具体见如下图：\r\n\r\n<object data=\"https://dvcs.w3.org/hg/webcomponents/raw-file/tip/assets/images/shadow-stack.svg\" width=\"500\" height=\"600\"></object>\r\n\r\n总结一下：\r\n\r\n- 最近申请的shadow DOM 子树最可能在\\<content\\>插入点获得最新的子树\r\n- 以此类推\r\n- 直到当前的shadow DOM子树没有\\<shadow\\>，那么其就是这个元素最后的DOM子树\r\n\r\n6.5 CSS 和 Shadow DOM\r\n-------------------------------------\r\n当构建自定义元素时自然要考虑属性、内容和API接口. 这与页面渲染同等重要. Shadow DOM 提供给开发者很多方式控制shadow DOM内容的样式.\r\n\r\nshadow DOM 子树有一个不看见的边界，user agent的样式默认生效，而不是定制的样式. 派生的元素依旧有效，这不是我们想要的. 在上面的scailing-watch的例子里，如果页面内容被渲染成绿色，如果要保持整体风格，shadow DOM内的文本由于color属性由于继承性质也会是绿色，不过设定了所有\\<div\\>元素橙色边框， 那direction indicator不会有橙色边框因为__border__并不是具有继承性质的属性\r\n\r\n一个shadow根节点有两个属性控制行为. applyAuthorStyles（开发者样式）属性，shadow DOM 会匹配最接近的样式，注意这个属性只能匹配shadow DOM 子树. 使用时要注意\"n\"代选择器\r\n\r\n如果__applyAuthorStyles__设置为false，__resetStyleInheritance__设置为true，样式会清空. 元素会被与页面样式隔离，你可以通过浏览器重置样式\r\n\r\n在插入点有相似的界限. shadow DOM子树的样式不会再插入点分布的元素上生效. 不过要是通过选择器想渲染某一部分特定内容， 可以用[::distributed pseudo-selector](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#distributed-pseudo-element)，如下：\r\n\r\n```html\r\n<!-- #ticker's shadow -->\r\n<template id=\"u\">\r\n  <style>\r\n    content::distributed(*) {\r\n      display: inline-block;\r\n    }\r\n    *::distributed(.breaking) {\r\n      text-shadow: 0 0 0.2em maroon;\r\n      color: orange;\r\n    }\r\n  </style>\r\n  <content class=\"highlight\" select=\".breaking\"></content>\r\n  <content></content>\r\n</template>\r\n```\r\n\r\n上述包含了两个规则，选择器的左半部分是shadow DOM 生效；括号内代表适用元素。第一个选择器对\\<content\\>的所有元素有效；第二个选择器对类对象为breaking的元素有效\r\n\r\nShadowDOM 也可以定制宿主元素的样式. 代码如下：\r\n\r\n```html\r\n<!-- #ticker's shadow -->\r\n<template id=\"u\">\r\n  <style>\r\n    @host {\r\n      :scope {\r\n        white-space: nowrap;\r\n        overflow-style: marquee-line;\r\n        overflow-x: marquee;\r\n      }\r\n    }\r\n    content::distributed(*) {\r\n      display: inline-block;\r\n    }\r\n    *::distributed(.breaking) {\r\n      text-shadow: 0 0 0.2em maroon;\r\n      color: orange;\r\n    }\r\n  </style>\r\n  <content class=\"highlight\" select=\".breaking\"></content>\r\n  <content></content>\r\n</template>\r\n```\r\n最后，有两种方式可以使shadow DOM 子树的样式与页面保持一致. 首先通过分配一个伪ID暴漏shadow DOM 子树中的特定元素，开发者可以定制其样式. 例如：\r\n\r\n```html\r\n<script>\r\n// Set up shadow DOM\r\n…\r\nvar ticker = r.querySelector('#ticker');\r\nticker.pseudo = 'x-ticker';\r\n…\r\n</script>\r\n\r\n<!-- change the appearance of the ticker part -->\r\n<style>\r\n#news::x-ticker {\r\n  background: gray;\r\n  color: lightblue;\r\n}\r\n</style>\r\n```\r\n\r\n另一种方法是通过CSS变量进行控制，如下：\r\n\r\n```html\r\n<!-- #ticker's shadow -->\r\n<template id=\"u\">\r\n  <style>\r\n    @host {\r\n      :scope {\r\n        white-space: nowrap;\r\n        overflow-style: marquee-line;\r\n        overflow-x: marquee;\r\n      }\r\n    }\r\n    content::distributed(*) {\r\n      display: inline-block;\r\n    }\r\n    *::distributed(.breaking) {\r\n      text-shadow: 0 0 0.2em var(highlight-accent, maroon);\r\n      color: var(highlight-primary, orange);\r\n    }\r\n  </style>\r\n  <content class=\"highlight\" select=\".breaking\"></content>\r\n  <content></content>\r\n</template>\r\n\r\n<!-- change the appearance of the ticker part -->\r\n<style>\r\n#news::x-ticker {\r\n  background: gray;\r\n  color: lightblue;\r\n  var-highlight-primary: green;\r\n  var-highlight-accent: yellow;\r\n}\r\n</style>\r\n```\r\n伪元素方法针对特定元素保持页面样式非常有用，而CSS变量则对不想重复指定的属性集（主题风格）非常有用. \r\n\r\n6.6 Shadow DOM中的事件\r\n----------------------------------------\r\n为了确保shadow DOM子树中的元素不会暴露给外部子树，会有很多工作来分发内部子树事件. \r\n首先，shadow DOM 子树会阻止事件如mutation和selectstart外部监听. 那些能够穿过shadow DOM的范围并且重定向的的事件，它们的__target__和__relatedTarget__的会指向shadow DOM子树的宿主元素. 在一些情况下，如__DOMFocusIn__，__mouseover__，__mouseout__事件需要特别注意，如果你在shadow DOM的两个元素中间移动鼠标，会出现鼠标从本身移动到它本身这种诡异的事件\r\n\r\n\r\n7 Imports\r\n----------------------------------------\r\n规范标准见这里[The HTML Imports specification](https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/imports/index.html)\r\n\r\nCustom elements 和 decorators可以通过文件的方式引入：\r\n\r\n```html\r\n<link rel=\"import\" href=\"goodies.html\">\r\n```\r\n\r\n只有\\<decorator\\>元素和\\<element\\>能被user agent解析，脚本也可以通过__import__属性获取DOM.  跨域检索的文档可以通过CORS判定这些定义是否可以跨站运行. \r\n\r\n\r\nSuetMing 保留部分权力。基于“[CC 3.0 BY-SA 协议](http://creativecommons.org/licenses/by-sa/3.0/)”发布\r\n","google":"UA-40716915-1","note":"Don't delete this file! It's used internally to help with page regeneration."}